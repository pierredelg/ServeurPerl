#!/usr/bin/perl

use strict;
use warnings;
use Socket;

##### VARIABLES DE FONCTIONNEMENT #####

#port de connexion du Serveur
my $port = 8080;

#Chemin vers un fichier HTML envoyé en cas d'erreur trouvée
my $cheminError = "/tmp/web/s/error.html";

#Nom de base du fichier quand la ressource demandée est un répertoire
#et qu'il existe bien un fichier dans ce répertoire
my $index = "index.html";

#Chemin vers le fichier contenant les logs
my $logfile = "/tmp/web/comanche.log";

#Nombre maximal de requetes à traiter en même temps
my $clients = 10;


#méthode qui lit le fichier conf
sub lireFichierConf{
    
    #Ouverture et lecture du fichier comanche.conf
    open my($file),'<', './comanche.conf' or die "Impossible d'ouvrir le fichier : $!\n";

    #On lit chaque ligne du fichier
    while( my $line = <$file> ) {

        #On supprime le \n de la ligne
    	chomp($line);

        #On vérifie le contenu de chaque lignes
    	verifierLigneConf($line);
    }
}

#méthode qui verifie les lignes de configuration 
#commencant par set
sub verifierSet{
    #On récupere la ligne passé en parametre
    my $line = "@_";
    
    #On répartit chaque élément de la ligne séparés par des espaces dans un tableau
    my @tab = split(/\s+/, "$line");

    #On récupere le deuxieme élément du tableau
    #correspondant à la variable
    my $variable = "$tab[1]";

    #On vérifie la nature de la variable
    if($variable eq "port") {
	       
    }elsif($variable eq "error") {
		
    }elsif($variable eq "index") {

    }elsif($variable eq "logfile") {

    }elsif($variable eq "clients") {

    }else {
        #Si la variable est inconnue on indique l'erreur
	   die "$variable est une variable non connue !\n";
    }
}

#méthode qui verifie les lignes de configuration 
#commencant par route
sub verifierRoute{

    #On récupere la ligne passé en parametre
    my $line = "@_";

    #On répartit chaque élément de la ligne séparés par des espaces dans un tableau
    my @splitLine = split(/\s+/, "$line");

    my $regexp1 = "$splitLine[1]";

    my $to = "$splitLine[2]";

    my $regexp2 = "$splitLine[3]";
}

#méthode qui verifie les lignes de configuration
#commencant par exec
sub verifierExec{
    #On récupere la ligne passé en parametre
    my $line = "@_";

    #On répartit chaque élément de la ligne séparés par des espaces dans un tableau
    my @splitLine = split(/\s+/, "$line");

    my $regexp1 = "$splitLine[1]";

    my $from = "$splitLine[2]";

    my $regexp2 = "$splitLine[3]";
}

#méthode qui verifie chaque ligne du fichier de configuration
sub verifierLigneConf{

    #On récupere la ligne envoyée en parametre
    my $line = "@_";
   
    #On remplace les lignes commençant par un # par une chaine vide
    $line =~ s/(?m)^#.*$//;

    #On conserve ce qui se trouve entre les caractères d'espacements
    $line =~ s/\s*(.*)\s*/$1/;

    #On supprime la partie suivant le # de la ligne
    $line =~ s/(.*)#(.*)/$1/;
    
    #On vérifie que la ligne n'est pas vide
    if($line ne ""){

	    print " line => $line\n";

        #On répartit chaque élément de la ligne séparés par des espaces dans un tableau
    	my @splitLine = split(/\s+/, "$line");
	    print " tableau => @splitLine\n";

        #On récupere le premier mot du tableau
    	my $ordre = "$splitLine[0]";
    	print "ordre : $ordre\n";

        #On vérifie la nature de l'ordre
    	if($ordre eq "set") {

            #On vérifie le contenu de la ligne commençant par set
    	    verifierSet("$line");
	    
    	}elsif($ordre eq "route") {

	        #On vérifie le contenu de la ligne commençant par route
    	    verifierRoute("$line");
	    
    	}elsif($ordre eq "exec") {

	        #On vérifie le contenu de la ligne commençant par exec
    	    verifierExec("$line");   
 
    	}else {
	       #Si l'ordre n'est pas connu on affiche une erreur
    	  die "$ordre est un ordre non connu !\n";
    	}
    }
}


lireFichierConf();
socket(SERVER, PF_INET, SOCK_STREAM, getprotobyname("tcp")) or die("socket");
setsockopt(SERVER, SOL_SOCKET, SO_REUSEADDR, 1);


my $addr = sockaddr_in("3000", INADDR_ANY);
bind(SERVER, $addr) or die("bind: $!");
listen(SERVER, SOMAXCONN) or die("listen: $!");

print "En attente de client\n";
accept(CLIENT, SERVER) or die("accept");

print "Client connecté\n";
select(CLIENT);
$| = 1;
select(STDOUT);
while (<CLIENT>) {
    chomp;
    print "Client: $_\n";
    print CLIENT "Serveur: $_\n";
}
close(CLIENT);
close(SERVER);
print "Fini\n";
